#PHP高级课之旅


##一,学习目标
	1,语法的学习
	2,面向对象的编程思想学习

##二,面向过程和面向对象 对比
	1,面向过程(单身屌丝)
		饿了, 自己做饭
		渴了,自己烧水
		空虚寂寞了,自己玩LOL
	
	2,面向对象(有对象了,长的像柳岩)
		饿了 , 柳岩去做饭
		渴了, 柳岩去烧水
		空虚寂寞了, 柳岩陪我一起LOL

##三, 对象
		具有一定功能和特征的事物 就是 对象
		能满足某种需求的事物  就是 对象


##四,类
		具有相同功能和特征的 对象的 抽象  就是类
		类这个东西是思想上的

		类的实例化(实体化) 称之为 对象
		对象的抽象化 就是 类
		
	
##五,类比
	
	马良   		画的画   	从画中走出来的事物
	程序猿  		  类     		对象


##六,类的声明
	格式
	class 类名{}

	成员属性 特征
	注意:
		在定义成员属性时 必须要加修饰符PPP(public protected private)
		成员属性的初始值可有可无
		不能使用函数,变量给成员属性赋值,php5.4时不能使用运算

	成员方法 功能
		在定义时修饰符可有可无 如果不加修饰符 默认public
		参数可有可无
		返回值可有可无

##七,对象的实例化
	格式
	$obj = new 类名();

	打印格式
	object(Phone)[1]
		  public 'brand' => string '锤子' (length=6)
		  public 'size' => null
		  public 'color' => string 'red' (length=3)

	object ==>数据类型  对象
	Phone ==> 当前对象属于哪个类实例化的结果
	[1] ==> 索引,代表当前这个对象 在脚本中是第几个对象

		修饰符 属性名 => 属性值类型   属性值


##八, this
	this 单词本身是  这个 的意思
	$this在成员方法中使用,代表的是当前这个对象
	哪个对象来调用当前这个方法,$this在方法中就代表这个对象


##九, 构造方法
	构造方法是一个特殊的成员方法
	不需要调用,可以自动执行
	方法名 __construct	与类名同名的方法也可以称为构造方法
	执行场景
		当使用new关键字来实例化对象时 自动触发
	
	作用:
		用于当前对象的初始化操作


##十,析构方法
	也是一个特殊的成员方法
	不需要调用,自动执行,该方法中没有任何参数
	方法名:
		__destruct
	执行场景:
		当对象被销毁时自动触发 
		对象什么时候会销毁?
			1,脚本执行完毕
			2,使用unset 手动销毁对象
			3,重新赋值,覆盖了原来的变量
	
	注意,是对象被销毁后调用了析构方法,而不是调用析构方法来销毁对象


云笔记
	


#面向对象第二天  

##封装
	封装就是使用修饰符来修饰成员属性和成员方法,
	最大限度的隐藏对象的内部细节,保证对象的完整性和安全性

	注意:封装是进行访问控制,但不是拒绝访问

	PPP  
				public(公有)  protected(受保护)  private(私有的)
	在类的内部     ok 				ok 				ok
	在类的外部     OK 				no 				no


###魔术方法
	// 魔术方法  就是有自己自动执行的场景 (不需要调用,自己触发)
	// music  ==> gusic

		g ==> __get()
			触发场景:
				当对对象中非公有或不存在的成员属性进行获取时,会自动触发
				并且将属性名 作为第一个参数
		u ==> __unset()
			对对象中非公有或不存在的成员属性使用unset进行销毁时,会自动触发
			并将属性名 作为第一个参数
		s ==> __set()
			触发场景:
				当对对象中非公有或不存在的成员属性进行赋值时,会自动触发
				将属性名作为第一个参数,属性值作为第二个参数获取
		i ==> __isset()
			当对对象中非公有或不存在的成员属性使用isset或empty进行检测时 会自动触发
			并将属性名 作为第一个参数
		c ==> __call()
			对对象中不存在或非公有的成员方法进行调用时 自动触发
			将调用的方法名作为第一个参数,调用方法时的参数列表作为第二个参数(数组)



##继承
	继承的使用场景:
		当别人有,自己没有,去继承那个人的,叫一声爹
	继承的格式
		class A  extends B{}
		当A类继承了B类,A类就拥有了B类中所有的成员属性和成员方法,除了私有成员

###访问权限
					public   protected  private
	在类的内部 		  ok 		ok 			ok
	在子类的内部  	  ok  		ok          X
	在类的外部 		  ok 		 X 			X

###子类对父类方法的重写(覆盖)
		如果子类出现了与父类同名的方法,就是对父类方法的重写
		在调用该方法时 优先调用子类中的方法
###调用父类中的方法
		parent::方法名()

###php只支持单继承
		一个子类只能有一个父类,
		但是一个类可以被多个子类继承
		可以有多层继承关系
	

		如果需要使用多个类时,可以多层继承关系,链式继承
		class A extends B{}
		class B extends C{}
		class C extends D{}
		class D{}


###final 关键字    最终   常量

	只能用来修饰类 和 成员方法  不能用来修饰成员属性(因为有常量的意思)
	被final修饰的类不能被继承
	被final修饰的方法不能被子类覆盖重写
	作用:
		一是为了安全，二是没有必要
###static 静态
		可以和PPP修饰符一起修饰成员属性和成员方法,被它修饰的成员 称为 静态成员
		不需要使用new关键字类实例化对象就可以直接访问静态成员
		访问形式:
			在类的外部 类名::$属性名  类名::方法名()
			在类的内部 self::$属性名  self::方法名()

		在静态方法中不能使用$this关键字,只能访问静态成员(属性,方法)

		静态属性是作为该类对象的共有属性存在
###单态设计模式(单例,单件)
		在当前脚本中只产生一个该类对象,在同一个脚本中,一个类只能有一个实例化对象存在
	
		1,阻止在类的外部使用new关键字类实例化对象
			将构造方法私有化
		2,在类的内部声明方法创建一个对象给你
			声明静态方法 创建对象
		3,把创建的对象存入一个位置,存档 依据
			声明静态成员属性存放对象

			在静态方法中去判断是否有对象


###const 关键字  定义常量

	在类的内部定义常量(也可以在类的外部定义常量)

	格式
		const 常量名 = 常量值;

	访问形式
		类的内部 self::常量名
		类的外部 类名::常量名

	区别:
							   const      define
		在类的内部定义常量      ok         X
		在类的外部定义常量      ok         ok
		在流程控制中定义常量    X          ok
		使用变量,函数赋值       X          ok
		使用运算                ok(php5.4不可以)  ok


###instanceof 操作符
	用于检测当前对象是否属于某一个类的实例化结果
	检测当前对象是否属于该类或该类的后辈类实例化结果
###类型约束
	php中的类型约束
	php5.6 只能约束两种 复合类型 数组 对象
		数组(array)  对象(类名 抽象类名  接口名)
	php7 可以约束字符串类型
	php7 可以约束整型,如果浮点类型 取整
	php7 可以约束浮点型,如果整型 转浮点
	php7 可以约束布尔型,只能四种标量

##克隆  clone
		对象属于引用类型,普通的"="等价于 起别名 自带& 取地址符
		如果我们想完整的复制(克隆)一个对象时,使用clone

		$obj = new Class();
        $objectcopy=clone $obj;

        魔术方法 __clone
        	当使用clone克隆一个对象时 会自动触发,主要完成一些特殊属性的赋值操作

##__toString()
			当我们尝试输出一个对象时,会自动触发 魔术方法
		作用:
			代替对象进行字符串操作

##自动加载类  魔术函数
		__autoload()
	当使用一个不存在的类时,会自动触发
	并能够获取当前不存在的类名

	扩展:
		指定一个函数来实现自动加载类的功能
		spl_autoload_register()


##串行化
	保存或传输

	对象串行化(序列化) serialize() 返回一个包含字节流的字符串


		在串行化时 保留的是对象的属性和类名  没有方法


	反串行化(反序列化) unserialize()将串行化的结果变回原来的值

	魔术方法 
		__sleep()
			当执行串行化时自动触发
			注意,在该方法中必须要返回一个数组
			数组中的值是串行化时要保留的属性

			作用:
				释放或关系一些 链接或资源
		__wakeup()
			执行反串行化时自动触发
			作用:
				重新打开 在sleep中关闭或释放的资源

##抽象类  abstract
		在类中如果至少有一个方法 ,没有方法体,直接分号结束
		那么这个方法叫做抽象方法,使用abstract修饰
		那么包含抽象方法的类,就必须是抽象类,使用abstract修饰
		
		如果想使用抽象类,必须定义类继承抽象类,实现里面的抽象方法
	
		不是抽象类中必须包含抽象方法
	作用:
		抽象类不能直接实例化对象,不能用
		对子类(实现类)起到约束作用


##接口 interface
		在类中只有抽象方法和常量,(抽象方法不能用abstract修饰)
		这样的类就可以定义为接口 
		
		一个类只能有一个父类,但是一个类可以去实现多个接口
		实现多个接口,必须实现所有接口中的所有抽象方法
		使用implements来实现 class A implement 接口1,接口2....
		
		和抽象类一样,不能直接使用,起到对子类(实现类)的约束

##多态
		对于同一个方法,传入不同的对象,实现了不同的效果,这就是多态的体现
		1,使用 接口 实现 多态
		2,使用 抽象类 实现 多态
		3,使用 普通类 实现 多态 (不推荐使用,对子类(实现类)没有约束作用)

###链式操作
		例:
		<?php 
			class Demo
			{
				public $str;
		
				public function func($s)
				{
					$this->str .= $s;
					return $this;//必须在允许的连贯操作方法中返回对象
				}
		
				public function select()
				{
					return $this->str;
				}
			}

			$a = new Demo();
			// 连贯操作 链式操作
			echo $a->func('AAA')->func('BBB')->func('CCC')->select();
	 ?>
##类和对象的常用函数

		 ###魔术常量
		 __FILE__ 当前文件的绝对路径
		 __LINE__ 当前行号
		 __FUNCTION__ 获取当前函数名
		 __METHOD__ 当前方法名
		 __CLASS__  当前类名
		
		###常用函数
		//检测类是否定义
		$res = class_exists('Person');
		//检测类中的成员属性是否定义
		$res = property_exists('Person','height');
		//检测对象中的成员属性是否定义
		$res = property_exists($lis,'sex');
		//获取对象中的成员属性列表,只能获取公有的
		$res = get_object_vars($lis);
		//获取类中的成员属性列表,只能获取公有的
		$res = get_class_vars('Person');
		//获取类中的成员方法列表,只能获取公有的
		$res = get_class_methods('Person');
		//获取对象的类名
		$res = get_class($lis);
	
		//返回指定类实现的接口,组成的数组
		$res = class_implements('Person');
##异常处理
	异常:程序猿认为的不正常,就是异常
	格式:
		try{
			//捕获异常,

			//抛出异常
			throw new Exception(异常信息,异常编号);
		}catch(Exception $e)
		{
			//进行异常处理
		}


	//扩展 了解
	//指定一个函数来进行异常处理
	set_exception_handler('');
	//详情见第六课时的例子
##PDO
	
###PDO的定义:
    pdo(php data object)是一个数据库的抽象层

###PDO的特点:

    1,跨数据库			(mysql,postgresql,oracle,mssql等多种数据库)

    2,支持预处理
	
    3,支持事务
	事务:将多条sql操作（增删改）作为一个操作单元，要么都成 
    功，要么都失败。

	事务的四大特性(ACID)
	原子性,一致性,隔离性,持久性

###PDO配置
		
	phpinfo()
	
	ext扩展目录
		extension_dir可以在LINUX下cd一下查找dll所在的目录

    php_pdo_mysql.dll	
	
	在配置文件中若没有开启则去打开此条配置重启服务即可
	extension=php_pdo_mysql.dll

###PDO使用

    一,基本使用 三大步
	
	1,实例化PDO
		数据库类型必须是小写
		实例化时的参数如下:
		$pdo = new PDO('mysql:host=localhost;dbname=lamp175;charset=utf8;port=3306','root','');
	
	2,发送sql指令
		$sql='sql语句';
		$pdo->query($sql);(返回的是对象查询时用)
		或
		$pdo->exec($sql);(返回的是受影响行数 增删改时用)
	3,处理返回结果
		
		当执行出现错误时
		$arr = $pdo->errorInfo();
		
		返回最后插入的数据id
		$id=$pdo->lastInsertId();
		只有pdo对象才能执行lastInsertId
		
		1, fetch()  提取一条
		
		2, fetchAll()提取所有
			其结果里面既有关联数组还有索引数组   可在fetchAll的参数中写上PDO::FETCH_ASSOC 关联形式数组 PDO::FETCH_NUM 索引形式
			
			setAttribute设置返回的结果类型(不推荐,用上面简便方法就行)
		3,foreach 遍历 (不推荐)

	 二,预处理
		1,实例化对象

		2,发送预处理指令
			prepare   使用?占位符 或者:
		
		3,绑定参数
			三种绑定方法
			①bindValue
			②bindParam()第二个参数必须是引用过去的
			③array()

		4,执行
			execute()

		5,处理结果
			①结果集 foreach fetch fetchAll
			②受影响行数 rowCount
			③最后插入的id lastInsertId
	
	 三,事务
		1,注意 表的类型必须是innodb
			①查看表结构
			 show create table 表明
			②修改表结构
			 alter table user engine=innodb
		
		2,命令行(cmd)里
			begin 开始事务
			commit 提交事务
			rollback 失败时事务回滚
		3,脚本中 
			beginTransaction 开始事务
			commit 提交事务
			rollBack 失败时事务回滚